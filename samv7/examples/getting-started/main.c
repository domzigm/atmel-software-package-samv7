/* ---------------------------------------------------------------------------- */
/*                  Atmel Microcontroller Software Support                      */
/*                       SAM Software Package License                           */
/* ---------------------------------------------------------------------------- */
/* Copyright (c) 2015, Atmel Corporation                                        */
/*                                                                              */
/* All rights reserved.                                                         */
/*                                                                              */
/* Redistribution and use in source and binary forms, with or without           */
/* modification, are permitted provided that the following condition is met:    */
/*                                                                              */
/* - Redistributions of source code must retain the above copyright notice,     */
/* this list of conditions and the disclaimer below.                            */
/*                                                                              */
/* Atmel's name may not be used to endorse or promote products derived from     */
/* this software without specific prior written permission.                     */
/*                                                                              */
/* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR   */
/* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE   */
/* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT */
/* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    */
/* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING         */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, */
/* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           */
/* ---------------------------------------------------------------------------- */

/**
 * \page getting-started Getting Started Example
 *
 * \section Purpose
 *
 * The Getting Started example will help new users get familiar with Atmel's
 * SAMV7/E7 family of Microcontrollers. This basic application shows the startup
 * sequence of a chip and how to use its core peripherals.
 *
 * \section Requirements
 *
 *  This package can be used with SAMV71 Xplained Ultra board or SAME70 Xplained board.
 *
 * \section Description
 *
 * The demonstration program makes two LEDs on the board blink at a fixed rate.
 * This rate is generated by using Time tick timer. The blinking can be stopped
 * by typing '1' or '2' in the console (one for each LED).
 *
 * \section Usage
 *
 * -# Build the program and download it inside the board.
 * Please refer to the Getting Started with SAM V71/E70 Microcontrollers.pdf
 * -# On the computer, open and configure a terminal application
 *    (e.g. HyperTerminal on Microsoft Windows) with these settings:
 *   - 115200 baud rate
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# LED(s) should start blinking on the board. In the terminal window, the
 *     following text should appear (values depend on the board and chip used):
 *    \code
 *     -- Getting Started Example xxx --
 *     -- xxxxxx-xx
 *     -- Compiled: xxx xx xxxx xx:xx:xx --
 *    \endcode
 * -# Press 'x' to start/stop the LEDx blinking
 *
 * \section References
 * - getting-started/main.c
 * - pio.h
 * - pio_it.h
 * - led.h
 * - trace.h
 */

/** \file
 *
 *  This file contains all the specific code for the getting-started example.
 *
 */

/*----------------------------------------------------------------------------
 *        Headers
 *----------------------------------------------------------------------------*/

#include "board.h"
#include <stdbool.h>
#include <stdio.h>

/*----------------------------------------------------------------------------
 *        Local definitions
 *----------------------------------------------------------------------------*/

/** IRQ priority for PIO (The lower the value, the greater the priority) */
#define IRQ_PRIOR_PIO    0

/** LED0 blink time, LED1 blink half this time, in ms */
#define BLINK_PERIOD        1000

/*----------------------------------------------------------------------------
 *        Local variables
 *----------------------------------------------------------------------------*/

/** LED0 blinking control. */
volatile bool bLed0Active = true;

/** LED1 blinking control. */
volatile bool bLed1Active = true;

/** Global timestamps in milliseconds since start of application */
volatile uint32_t dwTimeStamp = 0;

/** Global timestamps in milliseconds since start of application */
volatile uint32_t dwTcCounter = 0;

/*----------------------------------------------------------------------------
 *        Local functions
 *----------------------------------------------------------------------------*/

/**
 *  \brief Process Buttons Events
 *
 *  Change active states of LEDs when corresponding button events happened.
 */
static void ProcessButtonEvt(uint8_t ucButton)
{
	if (ucButton == 0) {
		bLed0Active = !bLed0Active;
		if (!bLed0Active) {
			LED_Clear(0);
		}
	} else {
		bLed1Active = !bLed1Active;
#if 2 == LED_NUM
		/* Enable LED#2 and TC if they were disabled */
		if (bLed1Active) {
			LED_Set(1);
		}
		/* Disable LED#2 and TC if they were enabled */
		else {
			LED_Clear(1);
		}
#endif
	}
}

#ifndef NO_PUSHBUTTON
/**
 *  \brief Handler for Button 1 rising edge interrupt.
 *
 *  Handle process led1 status change.
 */
static void _Button1_Handler(const Pin* pPin)
{
	if (pPin == &pinPB1) {
		ProcessButtonEvt(0);
	}
}

/**
 *  \brief Handler for Button 2 falling edge interrupt.
 *
 *  Handle process led2 status change.
 */
static void _Button2_Handler(const Pin* pPin)
{
	if (pPin == &pinPB2) {
		ProcessButtonEvt(1);
	}
}

/**
 *  \brief Configure the Push-buttons
 *
 *  Configure the PIO as inputs and generate corresponding interrupt when
 *  pressed or released.
 */
static void _ConfigureButtons(void)
{
	/* Configure PIO as inputs. */
	PIO_Configure(&pinPB1, 1);
	PIO_Configure(&pinPB2, 1);

	/* Adjust PIO denounce filter parameters, uses 10 Hz filter. */
	PIO_SetDebounceFilter(&pinPB1, 10);
	PIO_SetDebounceFilter(&pinPB2, 10);

	/* Initialize PIO interrupt handlers, see PIO definition in board.h. */
	PIO_ConfigureIt(&pinPB1, _Button1_Handler); /* Interrupt on rising edge  */
	PIO_ConfigureIt(&pinPB2, _Button2_Handler); /* Interrupt on rising edge */

	/* Enable PIO controller IRQs. */
	NVIC_EnableIRQ((IRQn_Type)pinPB1.id);
	NVIC_EnableIRQ((IRQn_Type)pinPB2.id);

	/* Enable PIO line interrupts. */
	PIO_EnableIt(&pinPB1);
	PIO_EnableIt(&pinPB2);
}

#else

/**
 *  \brief Handler for DBGU input.
 *
 *  Handle process LED1 or LED2 status change.
 */
static void _DBGU_Handler(void)
{
	uint8_t key;

	if (!DBG_IsRxReady())
		return;
	key = DBG_GetChar();
	switch (key) {
	case '1':
	case '2':
		ProcessButtonEvt(key - '1');
		break;
	}
}
#endif
/**
 *  \brief Configure LEDs
 *
 *  Configures LEDs \#1 and \#2 (cleared by default).
 */
static void _ConfigureLeds(void)
{
	uint32_t i;

	for(i = 0; i < LED_NUM; i++)
		LED_Configure(i);
}


/**
 *  Interrupt handler for TC0 interrupt. Toggles the state of LED\#2.
 */
void TC0_Handler(void)
{
	volatile uint32_t dummy;

	/* Clear status bit to acknowledge interrupt */
	dummy = TC0->TC_CHANNEL[0].TC_SR;

	/** Toggle LED state. */
	if (bLed1Active) {
#if 2 == LED_NUM
		LED_Toggle(1);
#endif
		printf("2 ");
	}
#ifdef NO_PUSHBUTTON
	_DBGU_Handler();
#endif

}

/**
 *  Configure Timer Counter 0 to generate an interrupt every 250ms.
 */
static void _ConfigureTc(void)
{
	uint32_t div;
	uint32_t tcclks;

	/** Enable peripheral clock. */
	PMC_EnablePeripheral(ID_TC0);
	/** Configure TC for a 4Hz frequency and trigger on RC compare. */
	TC_FindMckDivisor(4, BOARD_MCK, &div, &tcclks, BOARD_MCK);

	TC_Configure(TC0, 0, tcclks | TC_CMR_CPCTRG);
	TC0->TC_CHANNEL[0].TC_RC = (BOARD_MCK / div) / 4;

	/* Configure and enable interrupt on RC compare */
	NVIC_ClearPendingIRQ(TC0_IRQn);
	NVIC_EnableIRQ(TC0_IRQn);

	TC0->TC_CHANNEL[0].TC_IER = TC_IER_CPCS;

	/** Start the counter if LED1 is enabled. */
	if (bLed1Active) {
		TC_Start(TC0, 0);
	}
}


/*----------------------------------------------------------------------------
 *        Exported functions
 *----------------------------------------------------------------------------*/
/**
 *  \brief getting-started Application entry point.
 *
 *  \return Unused (ANSI-C compatibility).
 */
extern int main( void )
{

	/* Disable watchdog */
	WDT_Disable(WDT);

	/* Output example information */
	printf("\n\r-- Getting Started Example %s --\n\r", SOFTPACK_VERSION);
	printf("-- %s\n\r", BOARD_NAME);
	printf("-- Compiled: %s %s With %s--\n\r", __DATE__, __TIME__, COMPILER_NAME);

	/* Enable I and D cache */
	SCB_EnableICache();
	SCB_EnableDCache();

	/* Configure systick for 1 ms. */
	TimeTick_Configure();

	printf("Configure LED PIOs.\n\r");
	_ConfigureLeds();

	printf("Configure TC.\n\r");
	_ConfigureTc();

#ifndef NO_PUSHBUTTON
	printf("Configure buttons with denouncing.\n\r");
	_ConfigureButtons();
	printf("Press USRBP1 to Start/Stop LED D1 blinking.\n\r");
	printf("Press USRBP2 to Start/Stop LED D2 blinking.\n\r");
#else
	printf("No push buttons, uses DBG key 1 & 2 instead.\n\r");
	printf("Press 1 to Start/Stop LED D1 blinking.\n\r");
	printf("Press 2 to Start/Stop LED D2 blinking.\n\r");
#endif

	while (1) {
		/* Wait for LED to be active */
		while (!bLed0Active);

		/* Toggle LED state if active */
		if (bLed0Active) {
			LED_Toggle(0);
			printf("1 ");
		}

		/* Wait for 500ms */
		Wait(1000);
	}
}
